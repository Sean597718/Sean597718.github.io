<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹æ©Ÿç‰ˆ Map8 å°èˆª</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">
    <script src="https://cdn.staticfile.org/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.staticfile.org/popper.js/2.9.3/umd/popper.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <script src="https://kit.fontawesome.com/e4b7016783.js" crossorigin="anonymous"></script>
    <link
        href="https://api.map8.zone/css/gomp.css?key=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsIm5hbWUiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsImlhdCI6MTcxNzYzODg0Niwib2JqZWN0cyI6WyJcL21hcHNcL2pzIiwiXC9tYXBzXC9zdGF0aWMiLCJcL3BsYWNlXC9nZW9jb2RlIiwiXC9wbGFjZVwvZmluZHBsYWNlZnJvbXRleHQiLCJcL3BsYWNlXC9uZWFyYnlzZWFyY2giLCJcL3BsYWNlXC90ZXh0c2VhcmNoIiwiXC9wbGFjZVwvYXV0b2NvbXBsZXRlIiwiXC9kYXRhIiwiXC9zdHlsZXMiLCJcL3Nwcml0ZXMiLCJcL2ZvbnRzIiwiXC9yb3V0ZVwvZGlyZWN0aW9ucyIsIlwvcm91dGVcL2Rpc3RhbmNlbWF0cml4IiwiXC9yb3V0ZVwvdHJpcCIsIlwvcm9hZFwvbmVhcmVzdFJvYWRzIiwiXC9yb2FkXC9zbmFwVG9Sb2FkcyIsIlwvcm91dGVcL3ZycCIsIlwvYWRkcmVzc1wvc3RhbmRhcmRpemF0aW9uIl0sImV4cCI6MTcyMDE3MTgwNn0.Bk_GgGRH-vpYD-Rq4NDMa7XoiJ12LAadPBdTEA20Sh4"
        rel="stylesheet">
    <script type="text/javascript"
        src="https://api.map8.zone/maps/js/gomp-web-service-js-client.min.js?key=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsIm5hbWUiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsImlhdCI6MTcxNzYzODg0Niwib2JqZWN0cyI6WyJcL21hcHNcL2pzIiwiXC9tYXBzXC9zdGF0aWMiLCJcL3BsYWNlXC9nZW9jb2RlIiwiXC9wbGFjZVwvZmluZHBsYWNlZnJvbXRleHQiLCJcL3BsYWNlXC9uZWFyYnlzZWFyY2giLCJcL3BsYWNlXC90ZXh0c2VhcmNoIiwiXC9wbGFjZVwvYXV0b2NvbXBsZXRlIiwiXC9kYXRhIiwiXC9zdHlsZXMiLCJcL3Nwcml0ZXMiLCJcL2ZvbnRzIiwiXC9yb3V0ZVwvZGlyZWN0aW9ucyIsIlwvcm91dGVcL2Rpc3RhbmNlbWF0cml4IiwiXC9yb3V0ZVwvdHJpcCIsIlwvcm9hZFwvbmVhcmVzdFJvYWRzIiwiXC9yb2FkXC9zbmFwVG9Sb2FkcyIsIlwvcm91dGVcL3ZycCIsIlwvYWRkcmVzc1wvc3RhbmRhcmRpemF0aW9uIl0sImV4cCI6MTcyMDE3MTgwNn0.Bk_GgGRH-vpYD-Rq4NDMa7XoiJ12LAadPBdTEA20Sh4"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <style>
        .container-fluid {
            display: flex;
            flex-direction: column;
            height: 100vh;
            vertical-align: middle;
        }

        .map {
            height: 100%;
            background-color: #f7f7f7;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            border-radius: 10;
        }

        .alert-success {
            flex-grow: 1;
            width: 100%;
        }

        .card {
            background-color: #f7f7f7;
            margin-top: 6px;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .btn {
            margin-top: 6px;
            margin-bottom: 6px;
        }

        .geolocate-locked::after {
            content: "ğŸ”’";
            position: absolute;
            top: 0;
            right: 0;
            font-size: 12px;
        }

        .navigation-card {
            background-color: #f8f9fa;
            border: none;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .navigation-card .card-header {
            background-color: #007bff;
            color: white;
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
            padding: 15px;
        }

        .navigation-card .card-body {
            padding: 20px;
        }

        .navigation-info {
            margin-bottom: 15px;
        }

        .distance {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 10px;
        }

        .instruction {
            font-size: 1.2rem;
            display: flex;
            align-items: center;
        }

        .instruction i {
            margin-right: 10px;
            font-size: 1.5rem;
            color: #28a745;
        }

        .fare {
            font-size: 1.2rem;
            font-weight: bold;
            color: #dc3545;
        }

        @media (max-width: 768px) {
            .navigation-card {
                margin-bottom: 10px;
            }

            .distance {
                font-size: 1.2rem;
            }

            .instruction {
                font-size: 1rem;
            }

            .fare {
                font-size: 1rem;
            }
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div id="toastContainer" aria-live="polite" aria-atomic="true"
            style="position: fixed; top: 20px; right: 20px; z-index: 100;"></div>
        <<div class="card navigation-card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">è·¯å¾‘æŒ‡ç¤º</h5>
            </div>
            <div class="card-body">
                <div class="navigation-info">
                    <div id="card-distance" class="distance">300 å…¬å°ºå¾Œ</div>
                    <div id="card-instruction" class="instruction">
                        <i class="fas fa-arrow-right"></i>
                        <span>å‘å³è½‰é€²å…¥ä¸­æ­£è·¯</span>
                    </div>
                </div>
                <div id="card-fare" class="fare">ç›®å‰è»Šè³‡ï¼š50å…ƒ</div>
            </div>
    </div>
    <!-- Modal for start-->
    <div class="modal fade" id="startModal" tabindex="-1" aria-labelledby="startModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="startModalLabel"><i class="fa-solid fa-file-check fa-lg">è¡Œç¨‹ç¢ºèª</i>
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>ç›®çš„åœ°: <span id="destination"></span></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-success" data-bs-dismiss="modal" onclick="startJourney()">
                        <i class="bi bi-arrow-90deg-right"></i> å‡ºç™¼</button>
                    <button type="button" class="btn btn-warning" data-bs-dismiss="modal">
                        <i class="bi bi-x-circle-fill"></i> é—œé–‰</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Modal for end-->
    <div class="modal fade" id="endModal" tabindex="-1" aria-labelledby="endModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="endModalLabel"><i class="fa-solid fa-file-check fa-lg">ç¢ºèªæŠµé”</i></h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <b>è«‹ç¢ºèªæ˜¯å¦å·²æŠµé”ä¹˜å®¢ä¸Šè»Šé»</b>
                    <b>é€å‡ºå¾Œå°‡å‚³é€è¨Šæ¯å‘ŠçŸ¥ä¹˜å®¢ï¼</b>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-success" data-bs-dismiss="modal">
                        <i class="bi bi-clipboard-check-fill"></i> ç¢ºèªå·²æŠµé”</button>
                    <button type="button" class="btn btn-warning" data-bs-dismiss="modal">
                        <i class="bi bi-x-circle-fill"></i> é—œé–‰è¦–çª—</button>
                </div>
            </div>
        </div>
    </div>
    <div id="map8Map" class="map"></div>
    <div class="row">
        <div class="d-grid">
            <button class="btn btn-danger btn-block" type="button" data-bs-toggle="modal" data-bs-target="#endModal"
                onclick="endJourney()">
                <i class="fa-solid fa-flag-checkered fa-lg"></i><b> çµæŸè¡Œç¨‹</b>
            </button>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.1/dist/umd/popper.min.js"
        integrity="sha384-W8fXfP3gkOKtndU4JGtKDvXbO53Wy8SZCQHczT5FMiiqmQfUpWbYdTil/SxwZgAN"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.min.js"
        integrity="sha384-skAcpIdS7UcVUC05LJ9Dxay8AXcDYfBJqt1CJ85S/CFujBsIzCIv+l9liuYLaMQ/"
        crossorigin="anonymous"></script>
    <script
        src="https://api.map8.zone/maps/js/gomp.js?key=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsIm5hbWUiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsImlhdCI6MTcxNzYzODg0Niwib2JqZWN0cyI6WyJcL21hcHNcL2pzIiwiXC9tYXBzXC9zdGF0aWMiLCJcL3BsYWNlXC9nZW9jb2RlIiwiXC9wbGFjZVwvZmluZHBsYWNlZnJvbXRleHQiLCJcL3BsYWNlXC9uZWFyYnlzZWFyY2giLCJcL3BsYWNlXC90ZXh0c2VhcmNoIiwiXC9wbGFjZVwvYXV0b2NvbXBsZXRlIiwiXC9kYXRhIiwiXC9zdHlsZXMiLCJcL3Nwcml0ZXMiLCJcL2ZvbnRzIiwiXC9yb3V0ZVwvZGlyZWN0aW9ucyIsIlwvcm91dGVcL2Rpc3RhbmNlbWF0cml4IiwiXC9yb3V0ZVwvdHJpcCIsIlwvcm9hZFwvbmVhcmVzdFJvYWRzIiwiXC9yb2FkXC9zbmFwVG9Sb2FkcyIsIlwvcm91dGVcL3ZycCIsIlwvYWRkcmVzc1wvc3RhbmRhcmRpemF0aW9uIl0sImV4cCI6MTcyMDE3MTgwNn0.Bk_GgGRH-vpYD-Rq4NDMa7XoiJ12LAadPBdTEA20Sh4"></script>
    <script type="text/javascript"
        src="https://api.map8.zone/maps/js/gomp-web-service-js-client.min.js?key=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsIm5hbWUiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsImlhdCI6MTcxNzYzODg0Niwib2JqZWN0cyI6WyJcL21hcHNcL2pzIiwiXC9tYXBzXC9zdGF0aWMiLCJcL3BsYWNlXC9nZW9jb2RlIiwiXC9wbGFjZVwvZmluZHBsYWNlZnJvbXRleHQiLCJcL3BsYWNlXC9uZWFyYnlzZWFyY2giLCJcL3BsYWNlXC90ZXh0c2VhcmNoIiwiXC9wbGFjZVwvYXV0b2NvbXBsZXRlIiwiXC9kYXRhIiwiXC9zdHlsZXMiLCJcL3Nwcml0ZXMiLCJcL2ZvbnRzIiwiXC9yb3V0ZVwvZGlyZWN0aW9ucyIsIlwvcm91dGVcL2Rpc3RhbmNlbWF0cml4IiwiXC9yb3V0ZVwvdHJpcCIsIlwvcm9hZFwvbmVhcmVzdFJvYWRzIiwiXC9yb2FkXC9zbmFwVG9Sb2FkcyIsIlwvcm91dGVcL3ZycCIsIlwvYWRkcmVzc1wvc3RhbmRhcmRpemF0aW9uIl0sImV4cCI6MTcyMDE3MTgwNn0.Bk_GgGRH-vpYD-Rq4NDMa7XoiJ12LAadPBdTEA20Sh4"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <script type="text/javascript"
        src="https://api.map8.zone/maps/js/map8-js-route.js?key=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsIm5hbWUiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsImlhdCI6MTcxNzYzODg0Niwib2JqZWN0cyI6WyJcL21hcHNcL2pzIiwiXC9tYXBzXC9zdGF0aWMiLCJcL3BsYWNlXC9nZW9jb2RlIiwiXC9wbGFjZVwvZmluZHBsYWNlZnJvbXRleHQiLCJcL3BsYWNlXC9uZWFyYnlzZWFyY2giLCJcL3BsYWNlXC90ZXh0c2VhcmNoIiwiXC9wbGFjZVwvYXV0b2NvbXBsZXRlIiwiXC9kYXRhIiwiXC9zdHlsZXMiLCJcL3Nwcml0ZXMiLCJcL2ZvbnRzIiwiXC9yb3V0ZVwvZGlyZWN0aW9ucyIsIlwvcm91dGVcL2Rpc3RhbmNlbWF0cml4IiwiXC9yb3V0ZVwvdHJpcCIsIlwvcm9hZFwvbmVhcmVzdFJvYWRzIiwiXC9yb2FkXC9zbmFwVG9Sb2FkcyIsIlwvcm91dGVcL3ZycCIsIlwvYWRkcmVzc1wvc3RhbmRhcmRpemF0aW9uIl0sImV4cCI6MTcyMDE3MTgwNn0.Bk_GgGRH-vpYD-Rq4NDMa7XoiJ12LAadPBdTEA20Sh4"></script>
    <script>

        //javascript.js
        //set map options
        let map,
            gompWebServiceJsClient,
            route,
            start_at,
            json;
        let arrivalLatLng = [121.5173399, 25.0475613]; // ç›®çš„åœ°åº§æ¨™
        let goState = false; // æ˜¯å¦é–‹å§‹å°èˆª
        let stepsPath = []; // è·¯ç·šæš«å­˜
        let currentStepIndex = 1; // ç›®å‰æ‰€åœ¨æ­¥é©Ÿçš„ç´¢å¼•
        let currentStep = null; // ç›®å‰æ‰€åœ¨æ­¥é©Ÿ
        let nextStep = null; // ä¸‹ä¸€å€‹æ­¥é©Ÿ
        let nextPoint = null; // è¡Œå¾‘æ–¹å‘ä¸‹ä¸€å€‹é»åº§æ¨™
        let mapRotation = 0; // åœ°åœ–æ—‹è½‰è§’åº¦
        let NowLatLng = null; // ç›®å‰æ‰€åœ¨ä½ç½®
        let endPosition = null; // ç›®çš„åœ°ä½ç½®
        let positionRecord = []; // ç´€éŒ„ç§»å‹•è·¯å¾‘çš„é™£åˆ—
        let Pathpolyline = null; // ç§»å‹•è·¯å¾‘çš„ç·šæ®µ
        let estimatedDistance = 0; // é ä¼°è·é›¢
        let moveDistance = 0; // ç§»å‹•è·é›¢
        let totalMoveLength = 0; // ç§»å‹•è·¯å¾‘çš„ç¸½é•·åº¦
        let idlePosition = null; // æ€ é€Ÿé–‹å§‹ä½ç½®
        let Timer = 0; // è¨ˆæ™‚å™¨
        let startTime = null; // èµ·å§‹æ™‚é–“
        let endTime = null; // çµæŸæ™‚é–“
        let nowposition = null; // ç›®å‰æ‰€åœ¨ä½ç½®
        const cardTextDistance = document.querySelector("#card-distance");
        const cardTextInstruction = document.querySelector("#card-instruction");
        const cardTextFare = document.querySelector("#card-fare");
        let routeData; // è·¯ç·šè³‡æ–™
        let watchPositionId; // ç›£è½ä½ç½®çš„ ID
        let base_fare = 50; // åŸºæœ¬è»Šè³‡
        let fare = 0; // è»Šè³‡
        let isViewLocked = true; // é»˜èªé–å®šè¦–è§’
        const totalDistanceElement = document.getElementById("total-distance");
        const totalFareElement = document.getElementById("total-fare");

        //åˆå§‹åŒ–åœ°åœ–
        let marker;
        let startModal, endModal;
        document.addEventListener("DOMContentLoaded", function () {
            startModal = new bootstrap.Modal(document.getElementById("startModal"));
            endModal = new bootstrap.Modal(document.getElementById("endModal"));
            gomp.accessToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsIm5hbWUiOiJqaW5icy5pbmZvQGdtYWlsLmNvbSIsImlhdCI6MTcxNzYzODg0Niwib2JqZWN0cyI6WyJcL21hcHNcL2pzIiwiXC9tYXBzXC9zdGF0aWMiLCJcL3BsYWNlXC9nZW9jb2RlIiwiXC9wbGFjZVwvZmluZHBsYWNlZnJvbXRleHQiLCJcL3BsYWNlXC9uZWFyYnlzZWFyY2giLCJcL3BsYWNlXC90ZXh0c2VhcmNoIiwiXC9wbGFjZVwvYXV0b2NvbXBsZXRlIiwiXC9kYXRhIiwiXC9zdHlsZXMiLCJcL3Nwcml0ZXMiLCJcL2ZvbnRzIiwiXC9yb3V0ZVwvZGlyZWN0aW9ucyIsIlwvcm91dGVcL2Rpc3RhbmNlbWF0cml4IiwiXC9yb3V0ZVwvdHJpcCIsIlwvcm9hZFwvbmVhcmVzdFJvYWRzIiwiXC9yb2FkXC9zbmFwVG9Sb2FkcyIsIlwvcm91dGVcL3ZycCIsIlwvYWRkcmVzc1wvc3RhbmRhcmRpemF0aW9uIl0sImV4cCI6MTcyMDE3MTgwNn0.Bk_GgGRH-vpYD-Rq4NDMa7XoiJ12LAadPBdTEA20Sh4';
            initMap();
        });

        function initMap() {
            const initLatLng = [121.5173399, 25.0475613];
            const mapOptions = {
                container: 'map8Map',
                style: 'https://api.map8.zone/styles/go-life-maps-tw-style-std/style.json',
                center: initLatLng,
                zoom: 18,
                pitch: 60,
                bearing: 0,
            };

            map = new gomp.Map(mapOptions);
            map.addControl(new gomp.NavigationControl({ showZoom: false }));

            // åˆ›å»ºGeolocateControl
            const geolocateControl = new gomp.GeolocateControl({
                positionOptions: {
                    enableHighAccuracy: true,
                },
                trackUserLocation: true,
                showUserHeading: true,
                showUserLocation: true,

                maxZoom: 15 // è‡ªè¨‚ç¸®æ”¾å¤§å°

            });

            // å°†GeolocateControlæ·»åŠ åˆ°åœ°å›¾
            map.addControl(geolocateControl, 'bottom-right');
            // å°‡ GeolocateControl æ·»åŠ åˆ°åœ°åœ–å¾Œ
            geolocateControl._container.onclick = handleGeolocateClick;
            gompWebServiceJsClient = new GompWebServiceJsClient({ key: gomp.accessToken });
            map8Route = new Map8Route({
                gompWebServiceJsClient: gompWebServiceJsClient,
            });
            map.addControl(map8Route);

            // ç›‘å¬åœ°å›¾åŠ è½½å®Œæˆäº‹ä»¶
            map.on('load', function () {
                /* ç»‘å®šGeolocateControlçš„ç‚¹å‡»äº‹ä»¶
                geolocateControl._container.onclick = handleGeolocateClick;*/
                // åœ°å›¾åŠ è½½å®Œæˆåè‡ªåŠ¨è§¦å‘geolocation
                geolocateControl.trigger();

                // ç›‘å¬ä½ç½®æ›´æ–°äº‹ä»¶
                geolocateControl.on('geolocate', handleGeolocate);
                startModal.show();
                document.getElementById("destination").innerText = arrivalLatLng;
            });
            map.on('dragstart', function () {
                isViewLocked = false;
                showToast("è¦–è§’å·²è§£é–ï¼Œå¯è‡ªç”±ç§»å‹•åœ°åœ–");
            });

            function handleGeolocate(e) {
                if (typeof e.coords.latitude !== 'number' || typeof e.coords.longitude !== 'number') {
                    console.error('Invalid geolocation data:', e.coords);
                    return;
                }
                const position = {
                    lat: e.coords.latitude,
                    lng: e.coords.longitude
                };
                updateUserLocation(position);
            }
            function updateUserLocation(position) {
                // æ›´æ–°ä½ç½®å†å²
                if (typeof position.lat !== 'number' || typeof position.lng !== 'number') {
                    console.error('Invalid position:', position);
                    return;
                }
                const roundedPosition = {
                    lat: LatLngtoFloor(position.lat),
                    lng: LatLngtoFloor(position.lng)
                };
                NowLatLng = roundedPosition;
                positionRecord.push([roundedPosition.lng, roundedPosition.lat]);
                // æ›´æ–°åœ°å›¾ä¸Šçš„æ ‡è®°æˆ–å…¶ä»–éœ€è¦çš„ä½ç½®æ›´æ–°æ“ä½œ
                if (!nowposition) {
                    nowposition = new gomp.Marker({
                        position: roundedPosition,
                        map: map,
                    });
                } else {
                    nowposition.setLngLat(roundedPosition);
                }
                if (goState) {
                    recordPosition(NowLatLng);
                }
            }
        }

        function checkPositionOnRoute(position, routes) {
            //const currentPoint = {lng: position.lng, lat: position.lat};
            const currentPoint = turf.point([position.lng, position.lat])
            // éå†æ‰€æœ‰è·¯æ®µ
            for (let i = 0; i < routes.length - 1; i++) {
                const start = { lng: routes[i].maneuver.location[0], lat: routes[i].maneuver.location[1] };
                const end = { lng: routes[i + 1].maneuver.location[0], lat: routes[i + 1].maneuver.location[1] };
                // åˆ›å»ºå½“å‰è·¯æ®µçš„lineString
                const segment = turf.lineString([
                    [routes[i].maneuver.location[0], routes[i].maneuver.location[1]],
                    [routes[i + 1].maneuver.location[0], routes[i + 1].maneuver.location[1]]
                ]);
                // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åœ¨è¿™ä¸ªè·¯æ®µä¸Š
                if (turf.pointToLineDistance(currentPoint, segment) < 0.03) {
                    // å¦‚æœåœ¨è·¯æ®µä¸Šï¼Œè®¡ç®—åˆ°ä¸‹ä¸€ä¸ªè½¬å¼¯ç‚¹çš„è·ç¦»
                    const distanceToNextTurn = turf.distance(currentPoint, turf.point([end.lng, end.lat]));
                    nextPoint = end;
                    // æ›´æ–°å¯¼èˆªä¿¡æ¯
                    updateNavigationInfo(stepsPath[i + 1], distanceToNextTurn);

                    return true; // è¡¨ç¤ºåœ¨è·¯çº¿ä¸Š
                }
                else {
                    continue
                }
            }
            return false;
        }
        function updateNavigationInfo(nextStep, distance) {
            if (cardTextDistance && cardTextInstruction) {
                console.log("æ›´æ–°æŒ‡æ¨™")
                const infoDistance = formatDistance(distance);
                const infoInstruction = translateInstruction(nextStep.maneuver.modifier);
                const infoRoadName = nextStep.name;

                document.getElementById("card-distance").innerText = infoDistance;
                document.getElementById("card-instruction").innerHTML = `
        <i class="fas fa-arrow-right"></i>
        <span>${infoInstruction}é€²å…¥${infoRoadName}</span>
    `;
                updateInstructionIcon(infoInstruction);
            }
            else {
                console.error('Missing card text elements:', cardTextDistance, cardTextInstruction);
            }
        }

        function handlePositionUpdate(position) {
            console.log("è™•ç†ä½ç½®æ›´æ–°");
            const isOnRoute = checkPositionOnRoute(position, stepsPath);

            if (isOnRoute) {
                // åœ¨è·¯çº¿ä¸Šï¼Œç»§ç»­å½“å‰å¯¼èˆª
                console.log("åœ¨è§„åˆ’è·¯çº¿ä¸Š");
            } else {
                // ä¸åœ¨è·¯çº¿ä¸Šï¼Œé‡æ–°è§„åˆ’è·¯å¾„
                console.log("ä¸åœ¨è§„åˆ’è·¯çº¿ä¸Šï¼Œé‡æ–°è§„åˆ’è·¯å¾„");
                calcRoute(position, arrivalLatLng);
            }
        }

        // è™•ç† GeolocateControl é»æ“Šäº‹ä»¶çš„å‡½æ•¸
        function handleGeolocateClick(event) {
            // é˜²æ­¢äº‹ä»¶å†’æ³¡å’Œé»˜èªè¡Œç‚º
            event.stopPropagation();
            event.preventDefault();

            isViewLocked = true; // é‡æ–°é–å®šè¦–è§’
            showToast("è¦–è§’å·²è§£é–ï¼Œå¯è‡ªç”±ç§»å‹•åœ°åœ–");
            geolocateControl.trigger(); // è§¸ç™¼ä½ç½®æ›´æ–°
        }

        function addMarker(location, label) {
            for (let i = 0; i <= location.length - 1; i++) {
                marker = new gomp.Marker({
                    position: location[i],
                    map: map,
                    label: label,
                });

                setTimeout(function () {
                    marker.remove();
                }, 3000);
            }
        }

        function showToast(message, duration = 5000) {
            let toastElement = document.createElement("div");
            toastElement.classList.add("toast");
            toastElement.classList.add("show");

            toastElement.innerHTML = `
      <div class="toast-header">
        <strong class="me-auto">ç¨‹å¼é€šçŸ¥</strong>
        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
      <div class="toast-body">
        ${message}
      </div>
    `;

            document.getElementById("toastContainer").appendChild(toastElement);

            setTimeout(function () {
                toastElement.remove();
            }, duration);
        }
        function computeHeading(start, end) {
            const bearing = turf.bearing(
                turf.point([start.lng, start.lat]),
                turf.point([end.lng, end.lat])
            );
            return (bearing + 360) % 360; // ç¢ºä¿çµæœåœ¨ 0-360 åº¦ç¯„åœå…§
        }
        function headingCorrection(heading) {
            if (heading < 0) {
                heading += 360;
            }
            return heading;
        }

        function formatDistance(distance) {
            if (distance > 1) {
                const kilometers = distance.toFixed(1);
                return kilometers + " å…¬é‡Œå¾Œ";
            } else {
                let distanceM = distance * 1000
                const meters = Math.round(distance / 10) * 10;;
                return meters + " å…¬å°ºå¾Œ";
            }
        }

        function computeDistance(point1, point2) {
            if (!point1 || !point2 || typeof point1.lng !== 'number' || typeof point1.lat !== 'number' ||
                typeof point2.lng !== 'number' || typeof point2.lat !== 'number') {
                const from = turf.point([point1[0], point1[1]]);
                const to = turf.point([point2[0], point2[1]]);
                const distance = turf.distance(from, to);
                return Math.floor(distance);
            }
            const from = turf.point([point1.lng, point1.lat]);
            const to = turf.point([point2.lng, point2.lat]);
            const distance = turf.distance(from, to, { units: 'meters' });
            return Math.floor(distance);
        }

        function deg2rad(deg) {
            return deg * (Math.PI / 180);
        }

        function LatLngtoFloor(number) {
            let factor = Math.pow(10, 5);
            let truncatedNumber = Math.floor(number * factor) / factor;
            return truncatedNumber;
        }
        // æ›´æ–°ç›®å‰è¡Œé§›è·é›¢
        function updateEstimatedDistance() {
            estimatedDistance = positionRecord.reduce((total, currentValue, index, array) => {
                if (index > 0) {
                    const previousPoint = array[index - 1];
                    if (Array.isArray(previousPoint) && Array.isArray(currentValue) &&
                        previousPoint.length === 2 && currentValue.length === 2) {
                        return total + computeDistance(
                            { lng: previousPoint[0], lat: previousPoint[1] },
                            { lng: currentValue[0], lat: currentValue[1] }
                        );
                    } else {
                        console.error('Invalid position record:', previousPoint, currentValue);
                        return total;
                    }
                }
                return total;
            }, 0);
            estimatedDistance = Math.floor(estimatedDistance / 1000);
        }
        // æ›´æ–°è»Šè³‡
        function updateFare() {
            console.log("æ›´æ–°è»Šè³‡");
            if (cardTextFare) {
                let nowTimer = (Date.now() - startTime) / 60000;
                let currentFare = 50 + Math.floor(nowTimer) * 2 + estimatedDistance * 20;
                cardTextFare.innerHTML = "ç›®å‰è»Šè³‡ï¼š" + currentFare + "å…ƒ";
                console.log(Math.floor(nowTimer) + "åˆ†é˜" + estimatedDistance + "å…¬é‡Œ")
            }
        }
        // æ›´æ–°é¡é ­è¦–è§’
        function updateMapView(position) {
            console.log("æ›´æ–°åœ°åœ–è¦–è§’");
            if (isViewLocked) {
                let heading = computeHeading(position, nextPoint);
                nowposition.setLngLat(position);
                map.easeTo({
                    center: position,
                    zoom: 17,
                    pitch: 80,
                    bearing: heading,
                    duration: 1000 // æ·»åŠ éæ¸¡å‹•ç•«ï¼Œä½¿ç§»å‹•æ›´å¹³æ»‘
                });
            } else {
                // åƒ…æ›´æ–°ä½ç½®æ¨™è¨˜ï¼Œä¸æ”¹è®Šåœ°åœ–è¦–è§’
                nowposition.setLngLat(position);
            }
        }

        function updateInstructionIcon(instruction) {
            const iconElement = document.querySelector('#card-instruction i');
            let iconClass = 'fa-arrow-right'; // é»˜èªç‚ºå³ç®­é ­

            switch (instruction) {
                case 'å‘å·¦è½‰':
                    iconClass = 'fa-arrow-left';
                    break;
                case 'å‘å³è½‰':
                    iconClass = 'fa-arrow-right';
                    break;
                case 'ç›´è¡Œ':
                    iconClass = 'fa-arrow-up';
                    break;
                case 'è¿´è½‰':
                    iconClass = 'fa-arrows-retweet';
                    break;
                case 'å¾®å‘å·¦è½‰':
                    iconClass = 'fa-up-left';
                    break;
                case 'å¾®å‘å³è½‰':
                    iconClass = 'fa-up-right';
                    break;
                // å¯ä»¥æ ¹æ“šéœ€è¦æ·»åŠ æ›´å¤šæƒ…æ³
            }

            iconElement.className = `fas ${iconClass}`;
        }

        function recordPosition(position) {
            console.log("ç´€éŒ„ä½ç½®ç›¸é—œåŠŸèƒ½");
            // æ›´æ–°ç›®å‰è¡Œé§›è·é›¢èˆ‡è»Šè³‡
            updateEstimatedDistance();
            updateFare();
            // æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨è·¯çº¿ä¸Šå¹¶å¤„ç†
            handlePositionUpdate(position);
            // æ›´æ–°åœ°å›¾è§†å›¾
            updateMapView(position);
        }

        function showError(error) {
            console.log("Error getting location: " + error.message);
        }

        function startJourney() {
            if (startTime == null) {
                startTime = Date.now();
                endTime = null;
            }
            goState = true;

            calcRoute(NowLatLng, arrivalLatLng);
        }

        function endJourney() {
            positionRecord.forEach((currentValue, index) => {
                if (index > 0) {
                    const previousPoint = positionRecord[index - 1];
                    const distance = computeDistance(previousPoint, currentValue);
                    totalMoveLength += distance;
                    if (index === positionRecord.length - 1) {
                        totalMoveLength = Math.floor(totalMoveLength / 1000);
                    }
                }
            });
            endTime = Date.now();
            Timer = Math.floor((endTime - startTime) / 60000);
            console.log("çµç®—ä¸­...");
            final_time = Timer;
            final_distance = totalMoveLength;

            if (totalDistanceElement && totalFareElement) {
                final_fare = base_fare + Timer * 2 + totalMoveLength * 20;
                totalDistanceElement.innerText = final_distance + " å…¬é‡Œ";
                if (final_fare < 100 || isNaN(final_fare)) {
                    final_fare = 100;
                }
                totalFareElement.innerText = final_fare + " å…ƒ";
            }

        }

        function findNextPointsToCurrentLocationTest(currentLocation, overviewPath) {
            const coordinates = overviewPath;
            const currentPoint = currentLocation;
            for (let i = coordinates.length - 1; i >= 0; i -= 1) {
                let startPoint = coordinates[i];
                let endPoint = coordinates[i - 1];
                let lineString = turf.lineString([
                    [startPoint.lng, startPoint.lat],
                    [endPoint.lng, endPoint.lat]
                ]);
                if (booleanPointOnLine(currentPoint, lineString)) {
                    addMarker(endPoint, "O");
                    console.log(endPoint.lat + "," + endPoint.lng);
                    return endPoint;
                } else {
                    continue;
                }
            }
            addMarker(overviewPath[1], "O");
            return overviewPath[1];
        }

        async function calcRoute(origin, destination) {
            const query = await fetch(
                `https://api.map8.zone/route/car/${NowLatLng.lng},${NowLatLng.lat};${arrivalLatLng[0]},${arrivalLatLng[1]}.json?key=${gomp.accessToken}&steps=${true}&alternatives=${true}`,
                { method: 'GET' }
            );
            json = await query.json();
            console.log(json);
            routeData = json.routes[0];
            route = routeData.geometry.coordinates;
            stepsPath = routeData.legs[0].steps;
            console.log(stepsPath);
            nextPoint = { lng: stepsPath[1].maneuver.location[0], lat: stepsPath[1].maneuver.location[1] };
            const geojson = {
                type: 'Feature',
                properties: {},
                geometry: {
                    type: 'LineString',
                    coordinates: route
                }
            };
            // if the route already exists on the map, we'll reset it using setData
            if (map.getSource('route')) {
                map.getSource('route').setData(geojson);
            }
            // otherwise, we'll make a new request
            else {
                map.addLayer({
                    id: 'route',
                    type: 'line',
                    source: {
                        type: 'geojson',
                        data: geojson
                    },
                    layout: {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    paint: {
                        'line-color': '#3887be',
                        'line-width': 5,
                        'line-opacity': 0.75
                    }
                });

                /*stepsPath.forEach(step => {
                    const marker = new gomp.Marker()
                        .setLngLat(step.maneuver.location)
                        .setPopup(new gomp.Popup({ offset: 25 }) // add popups
                            .setHTML(`<h3>Type: ${step.maneuver.type}</h3><p>å‹•ä½œ:${step.maneuver.modifier}</p><p>æŒ‡ç¤º: ${step.name}</p>`))
                        .addTo(map);
                });*/

            };


        };

        // add turn instructions here at the end
        function translateInstruction(instruction) {
            const translations = {
                'uturn': 'è¿´è½‰',
                'straight': 'ç›´è¡Œ',
                'left': 'å‘å·¦è½‰',
                'right': 'å‘å³è½‰',
                'slight left': 'å¾®å‘å·¦è½‰',
                'slight right': 'å¾®å‘å³è½‰',
                'sharp left': 'å‘å·¦æ€¥è½‰',
                'sharp right': 'å‘å³æ€¥è½‰',

            };
            return translations[instruction] || instruction;
        }

        function countStepTypes(steps) {
            const typeCounts = {};
            steps.forEach(step => {
                const type = step.maneuver.type;
                if (typeCounts[type]) {
                    typeCounts[type]++;
                } else {
                    typeCounts[type] = 1;
                }
            });

            /*console.log("å„ type çš„æ•°é‡:");
            for (const type in typeCounts) {
                console.log(`${type}: ${typeCounts[type]}å€‹`);
            }*/
        }

        function updateInstruction() {
            document.getElementById("card-distance").innerText = formatDistance(Math.floor(stepsPath[currentStepIndex].distance));
            document.getElementById("card-instruction").innerText = translateInstruction(stepsPath[currentStepIndex].maneuver.modifier) + 'é€²å…¥' + stepsPath[currentStepIndex].name;
        }



    </script>
    </div>
</body>

</html>
